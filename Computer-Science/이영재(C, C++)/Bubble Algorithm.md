# __버블 정렬__
버블 정렬은 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법을 말한다.

버블 정렬은 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중한다.

이 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있다.

## __버블정렬의 이해__
Example)
<br><br>
`6 3 8 5 2 7 4 1`<br><br>
아래와 같은 8개의 숫자가 임의의 순서로 나열되어 있다.

먼저 가장 앞의 6과 3을 비교해서 순서를 바꾼다.
<br><br>
교환 전 : `6 3 8 5 2 7 4 1`<br>
교환 후 : `3 6 8 5 2 7 4 1`
<br><br>
다음 쌍인 6과 8을 비교하면, 6이 8보다 작으므로, 교환할 필요가 없다. 바로 다음 쌍인 8과 5를 비교해서 순서를 바꾼다.<br><br>
교환 전 : `3 6 8 5 2 7 4 1`<br>
교환 후 : `3 6 5 8 2 7 4 1`
<br><br>

이런 식으로 숫자 끝까지 진행하게되면, 다음과 같이 정렬이 된다.
<br><br>
`3 6 5 2 7 4 1 8`

`3 6 5 2 7 4 1 8` (교환)

`3 5 6 2 7 4 1 8` (교환)

`3 5 2 6 7 4 1 8` 

`3 5 2 6 7 4 1 8` (교환)

`3 5 2 6 4 7 1 8` (교환)

`3 5 2 6 4 1 7 8`
<br>...<br>
`1 2 3 4 5 6 7 8`
<br><br>

### __의사코드__
```
1.Repeat n-1 times
2.
3.    For i from 0 to n-2
4.
5.        if i'th and i+1'th elements out of order
6.
7.
8.            swap them
```
중첩 루프를 돌아야 하고, n개의 값이 주어졌을 때 각 루프는 각각 n-1번, n-2번 반복되므로  (n-1)*(n-2) = n^2-3n+2(n−1)∗(n−2)=n2
​​ −3n+2  번의 비교 및 교환이 필요하다.

여기서 가장 크기가 큰 요소는 n^2 이므로 위와 같은 코드로 작성한 버블 정렬 실행 시간의 상한은 O(n^2)이라고 말할 수 있다.

정렬이 되어 있는지 여부에 관계 없이 루프를 돌며 비교를 해야 하므로 위와 같은 코드로 작성한 버블 정렬의 실행 시간의 하한도 여전히 Ω(n^2)이 된다.